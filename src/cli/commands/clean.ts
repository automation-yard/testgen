import { Command } from 'commander';
import path from 'path';
import fs from 'fs';
import ora from 'ora';

interface CleanOptions {
  force?: boolean;
  tests?: boolean;
}

export function createCleanCommand(): Command {
  const command = new Command('clean')
    .description('Remove debug files and optionally generated test files')
    .option('-f, --force', 'Force deletion without DEBUG_MODE flag')
    .option('-t, --tests', 'Also remove generated test files')
    .action(async (options: CleanOptions) => {
      try {
        if (!process.env.DEBUG_MODE && !options.force) {
          throw new Error(
            'Clean command is only available when DEBUG_MODE=true or with --force flag'
          );
        }

        const spinner = ora('Cleaning files...').start();
        const cwd = process.cwd();
        const deletedFiles: string[] = [];

        // Walk through the directory recursively
        function walkDir(dir: string) {
          const files = fs.readdirSync(dir);

          files.forEach((file) => {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);

            if (stat.isDirectory()) {
              walkDir(filePath);
              // Remove empty directories after processing
              try {
                const remainingFiles = fs.readdirSync(filePath);
                if (remainingFiles.length === 0) {
                  fs.rmdirSync(filePath);
                }
              } catch (error) {
                // Directory might have been deleted by another iteration
              }
            } else {
              let shouldDelete = false;

              // Always check for debug files
              if (file.endsWith('.debug.txt')) {
                shouldDelete = true;
              }

              // Check for test files if --tests flag is provided
              if (
                options.tests &&
                /\.(test|spec)\.(js|jsx|ts|tsx)$/.test(file) &&
                fs
                  .readFileSync(filePath, 'utf8')
                  .includes('Generated by TestGen')
              ) {
                shouldDelete = true;
              }

              if (shouldDelete) {
                try {
                  fs.unlinkSync(filePath);
                  deletedFiles.push(path.relative(cwd, filePath));
                } catch (error) {
                  console.warn(`Failed to delete ${filePath}: ${error}`);
                }
              }
            }
          });
        }

        walkDir(cwd);

        if (deletedFiles.length > 0) {
          const debugFiles = deletedFiles.filter((f) =>
            f.endsWith('.debug.txt')
          );
          const testFiles = deletedFiles.filter(
            (f) => !f.endsWith('.debug.txt')
          );

          let message = '';
          if (debugFiles.length > 0) {
            message += `\nCleaned ${
              debugFiles.length
            } debug file(s):\n${debugFiles.map((f) => `  - ${f}`).join('\n')}`;
          }
          if (testFiles.length > 0) {
            message += `\nCleaned ${testFiles.length} test file(s):\n${testFiles
              .map((f) => `  - ${f}`)
              .join('\n')}`;
          }

          spinner.succeed(`Cleaning complete:${message}`);
        } else {
          spinner.info(
            `No ${options.tests ? 'debug or test' : 'debug'} files found`
          );
        }
      } catch (error) {
        console.error(
          'Error:',
          error instanceof Error ? error.message : String(error)
        );
        process.exit(1);
      }
    });

  return command;
}
